<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LapSpec Analyzer - Professional Edition</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        background-color: #222;
        color: #eee;
        font-family: sans-serif;
      }
      h1 { color: #4caf50; margin: 10px 0; }
      canvas {
        border: 2px solid #4caf50;
        background-color: #000;
        display: block;
        margin-top: 5px;
      }
      .controls {
        margin-top: 15px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: center;
        justify-content: center;
        max-width: 1000px;
        padding: 10px;
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
        border: 1px solid #444;
        padding: 5px 12px;
        border-radius: 5px;
        background: #333;
      }
      label { font-size: 12px; color: #aaa; }
      .val-disp { font-family: monospace; min-width: 30px; text-align: right; color: #4caf50; }
      button {
        padding: 8px 16px;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        background-color: #4caf50;
        color: white;
        font-weight: bold;
      }
      button:hover { background-color: #45a049; }
      button:disabled { background-color: #555; }
      .fft-btn { background-color: #3498db; }
      .fft-btn:hover { background-color: #2980b9; }
    </style>
  </head>
  <body>
    <h1>LapSpec Analyzer</h1>
    <canvas id="oscilloscopeCanvas" width="800" height="300"></canvas>
    <canvas id="frequencyCanvas" width="800" height="300"></canvas>
    
    <div class="controls">
      <div class="control-group">
        <button id="startButton">マイク開始</button>
        <button id="stopButton" disabled>停止</button>
        <button id="pauseResumeButton" disabled>一時停止</button>
      </div>

      <div class="control-group">
        <label>FFTサイズ:</label>
        <button class="fft-btn" onclick="changeFftSize(2048)">2048</button>
        <button class="fft-btn" onclick="changeFftSize(8192)">8192</button>
        <button class="fft-btn" onclick="changeFftSize(16384)">16384</button>
      </div>

      <div class="control-group">
        <label>マイク感度:</label>
        <input type="range" id="inputGainControl" min="0.1" max="10" value="1" step="0.1" />
        <span class="val-disp" id="inputGainValueDisplay">1.0</span>
      </div>

      <div class="control-group">
        <label>オシロ倍率:</label>
        <input type="range" id="displayGainControl" min="0.1" max="5" value="1" step="0.1" />
        <span class="val-disp" id="displayGainValueDisplay">1.0</span>
      </div>

      <div class="control-group">
        <label>スペクトル倍率:</label>
        <input type="range" id="freqDisplayGainControl" min="0.1" max="10" value="1" step="0.1" />
        <span class="val-disp" id="freqDisplayGainValueDisplay">1.0</span>
      </div>
    </div>

    <script>
      const oscilloscopeCanvas = document.getElementById("oscilloscopeCanvas");
      const oscCtx = oscilloscopeCanvas.getContext("2d");
      const frequencyCanvas = document.getElementById("frequencyCanvas");
      const freqCtx = frequencyCanvas.getContext("2d");

      let audioContext, analyser, inputGainNode, animationFrameId;
      let frequencyDataArray, peakDataArray, peakVelocities;
      let isPaused = false;
      let inputGainValue = 1, displayGainValue = 1, freqDisplayGainValue = 1;

      // ユーザーが追い込んだPD制御パラメータ
      const Kp = 0.000002;
      const Kd = 0.9999;

      // グリッド描画
      function drawOscilloscopeGrid() {
        const w = oscilloscopeCanvas.width, h = oscilloscopeCanvas.height;
        oscCtx.fillStyle = "#000"; oscCtx.fillRect(0, 0, w, h);
        oscCtx.strokeStyle = "#333";
        for(let i=0; i<=10; i++){ oscCtx.beginPath(); oscCtx.moveTo(i*w/10, 0); oscCtx.lineTo(i*w/10, h); oscCtx.stroke(); }
        for(let i=0; i<=8; i++){ oscCtx.beginPath(); oscCtx.moveTo(0, i*h/8); oscCtx.lineTo(w, i*h/8); oscCtx.stroke(); }
        oscCtx.strokeStyle = "#555";
        oscCtx.beginPath(); oscCtx.moveTo(0, h/2); oscCtx.lineTo(w, h/2); oscCtx.stroke();
      }

      function drawFrequencyGrid() {
        const w = frequencyCanvas.width, h = frequencyCanvas.height;
        freqCtx.fillStyle = "#000"; freqCtx.fillRect(0, 0, w, h);
        freqCtx.strokeStyle = "#333";
        for(let i=0; i<=10; i++){ freqCtx.beginPath(); freqCtx.moveTo(i*w/10, 0); freqCtx.lineTo(i*w/10, h); freqCtx.stroke(); }
        if (audioContext) {
          const sampleRate = audioContext.sampleRate, logMin = Math.log10(20), logMax = Math.log10(sampleRate/2), logRange = logMax - logMin;
          const labels = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
          freqCtx.fillStyle = "#999"; freqCtx.font = "10px Arial";
          labels.forEach(f => {
            const x = w * (Math.log10(f) - logMin) / logRange;
            if(x >= 0 && x <= w){
              freqCtx.strokeStyle = "#555"; freqCtx.beginPath(); freqCtx.moveTo(x, 0); freqCtx.lineTo(x, h); freqCtx.stroke();
              freqCtx.fillText(f >= 1000 ? (f/1000)+"k" : f, x + 2, h - 5);
            }
          });
        }
      }

      function changeFftSize(size) {
        if (!analyser) return;
        analyser.fftSize = size;
        const count = analyser.frequencyBinCount;
        frequencyDataArray = new Uint8Array(count);
        peakDataArray = new Float32Array(count).fill(0);
        peakVelocities = new Float32Array(count).fill(0);
        console.log("FFT size changed to:", size);
      }

      function updatePeakPhysics() {
        if (!peakDataArray) return;
        for (let i = 0; i < peakDataArray.length; i++) {
          const error = 0 - peakDataArray[i];
          const acceleration = error * Kp;
          peakVelocities[i] += acceleration;
          peakVelocities[i] *= Kd;
          peakDataArray[i] += peakVelocities[i];
          if (peakDataArray[i] < 0) { peakDataArray[i] = 0; peakVelocities[i] = 0; }
        }
      }

      function draw() {
        if (!isPaused) animationFrameId = requestAnimationFrame(draw);

        // --- オシロスコープ ---
        const timeData = new Uint8Array(analyser.fftSize);
        analyser.getByteTimeDomainData(timeData);
        drawOscilloscopeGrid();
        oscCtx.lineWidth = 1.5; oscCtx.strokeStyle = "#00FF00";
        oscCtx.beginPath();
        let sliceWidth = oscilloscopeCanvas.width / analyser.fftSize;
        for(let i=0, x=0; i < analyser.fftSize; i++, x += sliceWidth){
          const v = (timeData[i] / 128.0 - 1.0) * displayGainValue;
          const y = oscilloscopeCanvas.height / 2 + v * (oscilloscopeCanvas.height / 2);
          i === 0 ? oscCtx.moveTo(x, y) : oscCtx.lineTo(x, y);
        }
        oscCtx.stroke();

        // --- スペクトル ---
        analyser.getByteFrequencyData(frequencyDataArray);
        updatePeakPhysics();
        drawFrequencyGrid();

        const w = frequencyCanvas.width, h = frequencyCanvas.height;
        const sampleRate = audioContext.sampleRate;
        const logMin = Math.log10(20), logMax = Math.log10(sampleRate/2), logRange = logMax - logMin;
        const freqPerBin = (sampleRate/2) / analyser.frequencyBinCount;

        // リアルタイム波形(緑)
        freqCtx.beginPath();
        freqCtx.strokeStyle = "#00FF00";
        for (let x = 0; x < w; x++) {
          const f = Math.pow(10, logMin + (x / w) * logRange);
          const fNext = Math.pow(10, logMin + ((x + 1) / w) * logRange);
          const binSpan = (fNext - f) / freqPerBin;

          let val = 0;
          if (binSpan < 1) {
            // 【低域ガバガバ対策】1ピクセルが1ビンより狭い時は単一ビン参照
            const binIdx = Math.floor(f / freqPerBin);
            val = frequencyDataArray[binIdx] || 0;
          } else {
            // 【高域】範囲内の最大値を参照
            const bStart = Math.floor(f / freqPerBin), bEnd = Math.ceil(fNext / freqPerBin);
            for(let b = bStart; b <= bEnd; b++) {
              if(frequencyDataArray[b] > val) val = frequencyDataArray[b];
            }
          }

          // ピーク更新 (ピンポイントのビンを叩く)
          const bIdx = Math.floor(f / freqPerBin);
          if (bIdx < peakDataArray.length && val > peakDataArray[bIdx]) {
            peakDataArray[bIdx] = val;
            peakVelocities[bIdx] = 0;
          }

          const y = h - (val / 255) * h * freqDisplayGainValue;
          x === 0 ? freqCtx.moveTo(x, y) : freqCtx.lineTo(x, y);
        }
        freqCtx.stroke();

        // ピークドット描画(オレンジ)
        freqCtx.beginPath();
        freqCtx.strokeStyle = "rgba(255, 152, 0, 0.8)";
        for (let x = 0; x < w; x++) {
          const f = Math.pow(10, logMin + (x / w) * logRange);
          const fNext = Math.pow(10, logMin + ((x + 1) / w) * logRange);
          const binSpan = (fNext - f) / freqPerBin;
          let pVal = 0;
          if (binSpan < 1) {
            pVal = peakDataArray[Math.floor(f / freqPerBin)] || 0;
          } else {
            const bStart = Math.floor(f / freqPerBin), bEnd = Math.ceil(fNext / freqPerBin);
            for(let b = bStart; b <= bEnd; b++) { if(peakDataArray[b] > pVal) pVal = peakDataArray[b]; }
          }
          const py = h - (pVal / 255) * h * freqDisplayGainValue;
          x === 0 ? freqCtx.moveTo(x, py) : freqCtx.lineTo(x, py);
        }
        freqCtx.stroke();
      }

      async function startMic() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        inputGainNode = audioContext.createGain();
        changeFftSize(2048);
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext.createMediaStreamSource(stream).connect(inputGainNode);
        inputGainNode.connect(analyser);
        inputGainNode.gain.value = inputGainValue;
        document.getElementById("startButton").disabled = true;
        document.getElementById("stopButton").disabled = false;
        document.getElementById("pauseResumeButton").disabled = false;
        isPaused = false; draw();
      }

      function stopMic() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        if (audioContext) audioContext.close();
        document.getElementById("startButton").disabled = false;
        document.getElementById("stopButton").disabled = true;
        document.getElementById("pauseResumeButton").disabled = true;
        drawOscilloscopeGrid(); drawFrequencyGrid();
      }

      // スライダー類
      document.getElementById("inputGainControl").oninput = e => {
        inputGainValue = parseFloat(e.target.value);
        document.getElementById("inputGainValueDisplay").textContent = inputGainValue.toFixed(1);
        if (inputGainNode) inputGainNode.gain.value = inputGainValue;
      };
      document.getElementById("displayGainControl").oninput = e => {
        displayGainValue = parseFloat(e.target.value);
        document.getElementById("displayGainValueDisplay").textContent = displayGainValue.toFixed(1);
      };
      document.getElementById("freqDisplayGainControl").oninput = e => {
        freqDisplayGainValue = parseFloat(e.target.value);
        document.getElementById("freqDisplayGainValueDisplay").textContent = freqDisplayGainValue.toFixed(1);
      };
      document.getElementById("pauseResumeButton").onclick = () => {
        isPaused = !isPaused;
        document.getElementById("pauseResumeButton").textContent = isPaused ? "再開" : "一時停止";
        if (!isPaused) draw();
      };
      document.getElementById("startButton").onclick = startMic;
      document.getElementById("stopButton").onclick = stopMic;
      window.onload = () => { drawOscilloscopeGrid(); drawFrequencyGrid(); };
    </script>
  </body>
</html>